<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>아파트 인테리어 현황판</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        /* 뷰어 전용 스타일 추가 */
        body { background-color: #f0f2f5; padding: 40px; }
        .header { text-align: center; margin-bottom: 40px; }
        .legend { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 14px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }
        
        /* 상태별 색상 정의 */
        .status-before { background-color: #e0e0e0; color: #757575; } /* 시공전: 회색 */
        .status-ing { background-color: #fff3cd; border-color: #ffc107; color: #856404; } /* 시공중: 노랑 */
        .status-done { background-color: #d1e7dd; border-color: #198754; color: #0f5132; } /* 완료: 초록 */
    </style>
</head>
<body>

    <div class="header">
        <h1>101동 인테리어 시공 현황</h1>
        <div class="legend">
            <span class="legend-item"><div class="dot" style="background:#e0e0e0"></div>시공전</span>
            <span class="legend-item"><div class="dot" style="background:#ffc107"></div>시공중</span>
            <span class="legend-item"><div class="dot" style="background:#198754"></div>완료</span>
        </div>
    </div>

    <div id="grid-container" style="display: flex; justify-content: center;">
        Loading...
    </div>

<script type="module">
        import { SheetAPI } from './js/api.js';

        // 타입별 색상 팔레트 (파스텔톤 위주)
        // 미리 정의된 타입 외에는 해시 함수로 색상 자동 생성
        const TYPE_COLORS = {
            '84A': '#a5d6a7', // 녹색 계열
            '84B': '#81c784',
            '59A': '#90caf9', // 청색 계열
            '59B': '#64b5f6',
            '74':  '#fff59d', // 노랑 계열
            '102': '#ffcc80', // 주황 계열
            'PH':  '#ce93d8', // 보라 (펜트하우스)
            'special': '#e0e0e0' // 기타 시설
        };

        // 색상 가져오는 함수 (없으면 자동 생성)
        function getColorByType(type) {
            if (!type) return '#ffffff'; // 타입 없으면 흰색
            if (TYPE_COLORS[type]) return TYPE_COLORS[type];

            // 정의되지 않은 타입은 랜덤 파스텔 컬러 생성 (같은 타입은 같은 색 유지)
            let hash = 0;
            for (let i = 0; i < type.length; i++) {
                hash = type.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = hash % 360;
            return `hsl(${h}, 70%, 85%)`; // HSL로 부드러운 색상 생성
        }

        async function loadViewer() {
            const mainContainer = document.getElementById('grid-container');
            mainContainer.innerHTML = 'Loading data...';
            
            try {
                // 1. 전체 데이터 가져오기
                const res = await SheetAPI.action('read_all', {});
                if (res.result !== 'success') throw new Error(res.message);
                
                const units = res.data;
                if (!units || units.length === 0) {
                    mainContainer.innerHTML = "데이터가 없습니다.";
                    return;
                }

                // 2. 동별로 데이터 그룹화 (Grouping)
                // 결과 예시: { "101": [unit, unit...], "102": [...] }
                const unitsByDong = units.reduce((acc, unit) => {
                    const dong = unit.dong;
                    if (!acc[dong]) acc[dong] = [];
                    acc[dong].push(unit);
                    return acc;
                }, {});

                // 3. 화면 초기화 및 동별 렌더링 시작
                mainContainer.innerHTML = '';

                // 전체 데이터에서 사용된 모든 타입 추출 (범례용)
                const allTypes = new Set();
                units.forEach(u => {
                    if (u.type && u.is_active !== false) allTypes.add(u.type);
                });

                // 동 번호 순서대로 정렬 (101, 102, 103...)
                const sortedDongs = Object.keys(unitsByDong).sort();

                sortedDongs.forEach(dong => {
                    const dongUnits = unitsByDong[dong];
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'dong-wrapper';
                    
                    // [변경] 상단 타이틀 제거 (하단으로 이동했으므로)
                    // const title = document.createElement('h3'); ... (삭제)

                    const gridBox = document.createElement('div');
                    // 그리드 렌더링 시 최대 라인 수 반환받음 (하단 라벨 폭 맞추기 위해)
                    const maxLine = renderSingleGrid(dongUnits, gridBox); 
                    wrapper.appendChild(gridBox);

                    // [신규] 하단 동 표시 (셀 형태)
                    const dongLabel = document.createElement('div');
                    dongLabel.className = 'dong-label';
                    dongLabel.textContent = `${dong}동`;
                    // 테이블 너비와 맞추기 위해 width 설정 (CSS Grid라면 더 쉽지만 Table이므로)
                    // 간단히는 width: 100% 로 처리됨 (wrapper 기준)
                    wrapper.appendChild(dongLabel);

                    mainContainer.appendChild(wrapper);
                });

                // [신규] 범례(Legend) 생성
                renderLegend(allTypes);

            } catch (error) {
                console.error(error);
                mainContainer.innerHTML = `오류 발생: ${error.message}`;
            }
        }

        // 단일 동의 그리드를 그리는 함수 (기존 renderGrid 개선)
        function renderSingleGrid(units, container) {
            // 해당 동의 최대 층/라인 계산
            const maxFloor = Math.max(...units.map(u => u.floor));
            const maxLine = Math.max(...units.map(u => u.line)); // 리턴값용

            const table = document.createElement('table');
            table.className = 'grid-table'; 

            // 빠른 검색용 Map
            const unitMap = new Map();
            units.forEach(u => unitMap.set(`${u.floor}_${u.line}`, u));

            // 병합 처리를 위한 추적 배열 (2차원 배열: 방문 여부 체크)
            // visited[floor][line] = true/false
            const visited = Array.from({ length: maxFloor + 1 }, () => Array(maxLine + 1).fill(false));

            for (let f = maxFloor; f >= 1; f--) {
                const tr = document.createElement('tr');
                for (let l = 1; l <= maxLine; l++) {
                    // 이미 병합된 영역에 포함된 셀이면 건너뜀 (렌더링 안 함)
                    if (visited[f][l]) continue;

                    const unit = unitMap.get(`${f}_${l}`);
                    const td = document.createElement('td');

                    if (!unit || unit.is_active === false || unit.is_active === "false") {
                        // 삭제된 호실 (Void)
                        td.className = 'empty-cell'; // 투명 처리
                        td.style.border = 'none';
                    } else {
                        // 2. 데이터는 있지만 '사용안함(Inactive)'인 경우
                        // 구글 시트에서 boolean값은 TRUE/FALSE(대문자)로 올 수도 있고, true/false(bool)로 올 수도 있음
                        const isActive = (unit.is_active === true || unit.is_active === "TRUE" || unit.is_active === "true");

                        if (!isActive) {
                            // [수정됨] 사선 처리 클래스 적용
                            td.className = 'grid-cell inactive-cell';
                            // 호수는 보여주되 연하게, 혹은 아예 안 보여주려면 textContent를 비움
                            td.textContent = unit.ho; 
                        } else {
                            // 3. 정상 사용 중인 호실 (수정됨)
                                td.className = 'grid-cell'; // 상태 클래스 제거 (배경색으로 대체)
                                td.textContent = unit.ho;

                                // [핵심 수정] 상태 대신 '타입'에 따른 배경색 적용
                                // getColorByType 함수가 필요합니다 (스크립트 상단에 정의 필요)
                                td.style.backgroundColor = getColorByType(unit.type);
                                
                                // 특수 명칭(어린이집 등)인 경우 글씨 굵게
                                if (isNaN(unit.ho)) {
                                    td.style.fontWeight = 'bold';
                                }

                                // 클릭 이벤트
                                td.onclick = () => alert(`${unit.dong}동 ${unit.ho}호 (${unit.type}) 상세정보`);
                            }

                        td.dataset.id = unit.unique_id;

                        // 병합 처리 (공통)
                        const rs = unit.row_span || 1;
                        const cs = unit.col_span || 1;

                        if (rs > 1) td.rowSpan = rs;
                        if (cs > 1) td.colSpan = cs;

                        // 병합 영역 방문 처리 (공통)
                        for (let i = 0; i < rs; i++) {
                            for (let j = 0; j < cs; j++) {
                                if (i === 0 && j === 0) continue; 
                                const targetF = f - i; 
                                const targetL = l + j; 
                                if (targetF >= 1 && targetL <= maxLine) {
                                    visited[targetF][targetL] = true;
                                }
                            }
                        }
                    }
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
            container.appendChild(table);
        }

        function renderLegend(typesSet) {
        const legendBox = document.createElement('div');
        legendBox.className = 'legend-container';
        
        // 정렬해서 표시
        const types = Array.from(typesSet).sort();
        
        types.forEach(type => {
            const item = document.createElement('div');
            item.className = 'legend-item';
            
            const colorBox = document.createElement('div');
            colorBox.className = 'legend-color';
            colorBox.style.backgroundColor = getColorByType(type);
            
            const text = document.createElement('span');
            text.textContent = type;
            
            item.appendChild(colorBox);
            item.appendChild(text);
            legendBox.appendChild(item);
        });

        // 범례를 메인 컨테이너 하단이나 body 하단에 추가
        document.body.appendChild(legendBox); // 혹은 원하는 위치
    }
        loadViewer();
    </script>
</body>
</html>